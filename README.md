# Cars & Leads App - Flutter Clean Architecture + Auto Sync

## üì± Sobre o Projeto

Este √© um aplicativo Flutter desenvolvido seguindo os princ√≠pios de **Clean Architecture** e **SOLID**, utilizando **BLoC** para gerenciamento de estado. O app carrega dados de carros de uma API externa e permite que usu√°rios demonstrem interesse em comprar um carro, salvando essas informa√ß√µes localmente.

## üéØ Funcionalidades

- ‚úÖ **Listagem de Carros**: Carrega dados da API [https://wswork.com.br/cars.json](https://wswork.com.br/cars.json)
- ‚úÖ **Interface Intuitiva**: Cards com informa√ß√µes detalhadas dos carros
- ‚úÖ **Bot√£o "EU QUERO"**: Permite que usu√°rios demonstrem interesse
- ‚úÖ **Coleta de Dados do Usu√°rio**: Formul√°rio para nome, email e telefone
- ‚úÖ **Armazenamento Local**: Salva leads no SQLite
- ‚úÖ **Visualiza√ß√£o de Interessados**: Lista todos os leads salvos
- ‚úÖ **Offline First**: Cache local para funcionamento sem internet
- ‚úÖ **Pull-to-Refresh**: Atualiza√ß√£o por gesto nas p√°ginas de leads
- ‚úÖ **Auto-Sincroniza√ß√£o Configur√°vel**: Intervalos (1 / 5 / 15 min) para envio autom√°tico de leads pendentes
- ‚úÖ **Heur√≠stica de Valor de Carro**: Ajusta valores abreviados (ex: 50 => 50.000) antes de formatar
- ‚úÖ **Arquitetura Sliver nas listas**: Evita erros de viewport e melhora consist√™ncia de layout

## üèóÔ∏è Arquitetura

### Clean Architecture + SOLID

O projeto segue a **Clean Architecture** proposta por Robert Martin, organizada em camadas:

```
lib/
‚îú‚îÄ‚îÄ core/                          # N√∫cleo da aplica√ß√£o
‚îÇ   ‚îú‚îÄ‚îÄ di/                        # Inje√ß√£o de depend√™ncia
‚îÇ   ‚îú‚îÄ‚îÄ database/                  # Configura√ß√£o do banco de dados
‚îÇ   ‚îú‚îÄ‚îÄ errors/                    # Tratamento de erros
‚îÇ   ‚îú‚îÄ‚îÄ usecases/                  # Casos de uso base
‚îÇ   ‚îî‚îÄ‚îÄ widgets/                   # Widgets compartilhados
‚îú‚îÄ‚îÄ features/                      # Funcionalidades por feature
‚îÇ   ‚îî‚îÄ‚îÄ cars/                      # Feature de carros
‚îÇ       ‚îú‚îÄ‚îÄ data/                  # Camada de dados
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ datasources/       # Fontes de dados (API, Cache)
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ models/            # Modelos de dados
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ repositories/      # Implementa√ß√£o dos reposit√≥rios
‚îÇ       ‚îú‚îÄ‚îÄ domain/                # Camada de dom√≠nio
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ entities/          # Entidades de neg√≥cio
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ repositories/      # Contratos dos reposit√≥rios
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ usecases/          # Casos de uso
‚îÇ       ‚îî‚îÄ‚îÄ presentation/          # Camada de apresenta√ß√£o
‚îÇ           ‚îú‚îÄ‚îÄ bloc/              # Gerenciamento de estado (BLoC)
‚îÇ           ‚îú‚îÄ‚îÄ pages/             # P√°ginas da aplica√ß√£o
‚îÇ           ‚îî‚îÄ‚îÄ widgets/           # Widgets espec√≠ficos
‚îÇ   ‚îî‚îÄ‚îÄ leads/                     # Feature de lead
‚îÇ       ‚îú‚îÄ‚îÄ data/                  # Camada de dados
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ datasources/       # Fontes de dados (API, Cache)
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ models/            # Modelos de dados
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ repositories/      # Implementa√ß√£o dos reposit√≥rios
‚îÇ       ‚îú‚îÄ‚îÄ domain/                # Camada de dom√≠nio
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ entities/          # Entidades de neg√≥cio
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ repositories/      # Contratos dos reposit√≥rios
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ usecases/          # Casos de uso
‚îÇ       ‚îî‚îÄ‚îÄ presentation/          # Camada de apresenta√ß√£o
‚îÇ           ‚îú‚îÄ‚îÄ bloc/              # Gerenciamento de estado (BLoC)
‚îÇ           ‚îú‚îÄ‚îÄ pages/             # P√°ginas da aplica√ß√£o
‚îÇ           ‚îî‚îÄ‚îÄ widgets/           # Widgets espec√≠ficos
```

### Princ√≠pios SOLID Aplicados

1. **SRP (Single Responsibility Principle)**: Cada classe tem uma √∫nica responsabilidade
2. **OCP (Open/Closed Principle)**: C√≥digo aberto para extens√£o, fechado para modifica√ß√£o
3. **LSP (Liskov Substitution Principle)**: Subtipos substitu√≠veis por seus tipos base
4. **ISP (Interface Segregation Principle)**: Interfaces pequenas e espec√≠ficas
5. **DIP (Dependency Inversion Principle)**: Depend√™ncias abstratas, n√£o concretas

## üîß Tecnologias e Depend√™ncias

### Depend√™ncias Principais
```yaml
dependencies:
  flutter_bloc: ^8.1.3          # Gerenciamento de estado
  equatable: ^2.0.5             # Compara√ß√£o de objetos
  dio: ^5.3.2                   # Cliente HTTP
  sqflite: ^2.3.0               # Banco de dados SQLite
  get_it: ^7.6.4                # Inje√ß√£o de depend√™ncia
  json_annotation: ^4.8.1       # Anota√ß√µes JSON
  dartz: ^0.10.1                # Programa√ß√£o funcional
  intl: ^0.18.1                 # Formata√ß√£o e internacionaliza√ß√£o

dev_dependencies:
  build_runner: ^2.4.7          # Gera√ß√£o de c√≥digo
  json_serializable: ^6.7.1     # Serializa√ß√£o JSON
  bloc_test: ^9.1.4             # Testes para BLoC
  mockito: ^5.4.2               # Mocks para testes
  sqflite_common_ffi: ^2.3.0    # SQLite para testes
```

## üöÄ Como Executar

### Pr√©-requisitos
- Flutter SDK 3.9.0 ou superior
- Dart SDK
- Android Studio / VS Code
- Dispositivo Android/iOS ou emulador

### Passos para Execu√ß√£o

1. **Clone o reposit√≥rio**
```bash
git clone [https://github.com/BrunoDalI/teste_ws_work_flutter.git]
cd teste_ws_work_flutter
git checkout master
```

2. **Instale as depend√™ncias**
```bash
flutter pub get
```

3. **Gere os arquivos necess√°rios**
```bash
dart run build_runner build
```

4. **Execute o app**
```bash
flutter run
```

## üß™ Testes

Conjunto atual focado em fluxos cr√≠ticos de sincroniza√ß√£o e estado:

| Arquivo | Objetivo |
|---------|----------|
| `test/features/lead/bloc/lead_bloc_test.dart` | Transi√ß√µes principais de `LeadBloc` (carregar / salvar) |
| `test/core/sync/auto_sync_service_test.dart` | Verifica envio peri√≥dico e marca√ß√£o de leads como enviados |
| `test/features/lead/domain/lead_entity_test.dart` | Garante heur√≠stica de formata√ß√£o de valor de carro |

Execu√ß√£o:
```powershell
flutter test
```

Cobertura (opcional):
```powershell
flutter test --coverage
```

Observa√ß√£o: Foram usados fakes ao inv√©s de `mockito` para reduzir boilerplate e acelerar feedback.

## üìä Estrutura de Dados

### Car Entity
```dart
class Car {
  final int id;
  final int timestampCadastro;
  final int modeloId;
  final int ano;
  final String combustivel;
  final int numPortas;
  final String cor;
  final String nomeModelo;
  final double valor;
}
```

### Lead Entity
```dart
class Lead {
  final int? id;
  final int carId;
  final String userName;
  final String userEmail;
  final String userPhone;
  final DateTime createdAt;
  final String carModel;
  final double carValue;
}
```

## üóÑÔ∏è Banco de Dados

### Estrutura das Tabelas

#### Tabela Cars (Cache)
```sql
CREATE TABLE cars (
  id INTEGER PRIMARY KEY,
  timestampCadastro INTEGER NOT NULL,
  modeloId INTEGER NOT NULL,
  ano INTEGER NOT NULL,
  combustivel TEXT NOT NULL,
  numPortas INTEGER NOT NULL,
  cor TEXT NOT NULL,
  nomeModelo TEXT NOT NULL,
  valor REAL NOT NULL
);
```

#### Tabela Leads
```sql
CREATE TABLE leads (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  carId INTEGER NOT NULL,
  userName TEXT NOT NULL,
  userEmail TEXT NOT NULL,
  userPhone TEXT NOT NULL,
  createdAt INTEGER NOT NULL,
  carModel TEXT NOT NULL,
  carValue REAL NOT NULL
);
```

## üîÑ Fluxo de Dados

### Carregamento de Carros
1. **UI** solicita carros via BLoC
2. **BLoC** chama UseCase GetCars
3. **UseCase** chama Repository
4. **Repository** tenta buscar dados remotos
5. Se sucesso: salva no cache e retorna dados
6. Se falha: retorna dados do cache (se dispon√≠vel)
7. **BLoC** emite estado com dados ou erro
8. **UI** atualiza interface

### Salvamento de Lead
1. **UI** coleta dados do usu√°rio
2. **BLoC** recebe evento SaveLead
3. **BLoC** chama UseCase SaveLead
4. **UseCase** chama Repository
5. **Repository** salva no SQLite
6. **BLoC** emite estado de sucesso ou erro
7. **UI** mostra feedback

## üì± Interfaces

### Tela Principal (CarPage)
- Lista de carros em cards
- Pull-to-refresh
- Loading states
- Error handling
- Navega√ß√£o para tela de leads

### Tela de Leads (LeadsPage)
- Lista de interessados
- Informa√ß√µes do cliente
- Dados do carro de interesse
- Estados vazios

### Dialog de Dados (UserInfoDialog)
- Formul√°rio validado
- Campos: nome, email, telefone
- Valida√ß√µes em tempo real

### Auto-Sincroniza√ß√£o de Leads
1. UI ativa auto-sync selecionando intervalo.
2. `AutoSyncService.enable(interval)` inicia `Timer.periodic`.
3. A cada tick: busca leads `isSent=false` -> envia em lote -> marca como enviados -> emite `AutoSyncResult`.
4. P√°gina / BLoC escuta stream e dispara `LoadLeadsEvent` para refletir novos estados.
5. Desativa√ß√£o via `disable()` cancela timer e limpa previs√£o de pr√≥xima execu√ß√£o.

M√©tricas b√°sicas (expostas internamente): pr√≥xima execu√ß√£o (`nextRunAt`), intervalo e stream de resultados.

## üé® Design Patterns Utilizados

1. **Repository Pattern**: Abstra√ß√£o da camada de dados
2. **UseCase Pattern**: Encapsulamento da l√≥gica de neg√≥cio
3. **BLoC Pattern**: Gerenciamento de estado reativo
4. **Dependency Injection**: Invers√£o de controle
5. **Factory Pattern**: Cria√ß√£o de objetos
6. **Observer Pattern**: Comunica√ß√£o via streams

## ü§î Por que BLoC, SOLID, Clean Architecture e Dio?

### BLoC
- Separa√ß√£o clara de UI e l√≥gica de neg√≥cio via eventos/estados.
- Facilita testes unit√°rios isolando side-effects.
- Escal√°vel: m√∫ltiplos fluxos de estado podem coexistir sem acoplamento direto aos widgets.

### Clean Architecture
- Protege regras de neg√≥cio de detalhes de implementa√ß√£o (HTTP, banco, UI).
- Permite substitui√ß√£o de camadas (ex: trocar Dio por outro cliente) sem tocar dom√≠nio.
- Estrutura previs√≠vel reduz curva de aprendizado para novos contribuidores.

### Princ√≠pios SOLID
- SRP: cada classe com responsabilidade √∫nica (ex: UseCases finos, Reposit√≥rios abstratos).
- OCP: novos fluxos (ex: auto sync) adicionados sem modificar casos de uso existentes.
- LSP: abstra√ß√µes (repositories, usecases) podem ser trocadas por fakes/mocks em testes.
- ISP: interfaces enxutas (LeadRepository/CarRepository) evitam depend√™ncias desnecess√°rias.
- DIP: Dom√≠nio depende de abstra√ß√µes; infraestrutura injeta implementa√ß√µes concretas via DI (`get_it`).

### Dio
- Recursos avan√ßados (interceptors, cancel tokens, timeout configur√°vel) prontos para produ√ß√£o.
- Facilidade para adicionar logging e retry estrategicamente.
- Melhor controle de resposta/erros comparado ao `http` simples, com suporte robusto a FormData e Streams.

### Benef√≠cio Combinado
Juntos, BLoC + Clean Architecture + SOLID + Dio entregam:
- Manuten√ß√£o facilitada
- Alto n√≠vel de testabilidade
- Evolu√ß√£o incremental sem refatora√ß√µes amplas
- Clareza de fluxo (UI -> Evento -> BLoC -> UseCase -> Repository -> DataSource)


### Adicional
Aqui estou montando um guia para compartilhar conhecimento onde explico tudo com exemplos: 
https://brunodali.github.io/flutter_guide_webpage/

## ÔøΩÔ∏è Monitoramento e Qualidade (Flutter DevTools)
Uso sistem√°tico do DevTools para garantir estabilidade, performance e sa√∫de do app:

### Analyze (An√°lise Est√°tica)
- Comando peri√≥dico: `flutter analyze`.
- Objetivo: detectar imports n√£o usados, padr√µes incorretos e problemas antes do runtime.
- Resultado: c√≥digo mais consistente e menor risco de regress√µes silenciosas.

### Performance
- Aba Performance para observar timeline de frames e detectar jank.
- Otimiza√ß√µes aplicadas: remo√ß√£o de rebuilds desnecess√°rios (ex: consolidando scroll em `CustomScrollView`).
- Valida√ß√£o de anima√ß√£o suave na Splash (entrada do √≠cone de carro sem quedas de frame).

### Memory
- Monitoramento de heap durante navega√ß√£o CarPage -> LeadsPage -> LeadSyncPage.
- Confer√™ncia de descarte de controllers (AnimationController / timers em bloc/services).
- Resultado: aus√™ncia de crescimento cont√≠nuo (indicador de n√£o haver leak evidente).

### Widget Inspector
- Uso para inspecionar √°rvore e constraints ao resolver erro de viewport (scroll aninhado).
- Benef√≠cio: diagnosticou rapidamente necessidade de unificar estrutura em Slivers.

### Network
- Observa√ß√£o de chamadas Dio (lat√™ncia e payload) para confirmar cache vs remoto.
- Verifica√ß√£o de status codes e tempo m√©dio de resposta.

### Logging / Console
- Logs de estados de BLoC (transi√ß√µes) usados para validar fluxo de sincroniza√ß√£o autom√°tica.
- Simplifica√ß√£o: preferido logs pontuais ao inv√©s de verbose global para manter clareza.

### Timeline
- Inspe√ß√£o de eventos em sequ√™ncia durante sincroniza√ß√£o em lote para garantir que UI n√£o bloqueia.
- Uso complementar √† aba Performance para correlacionar picos de CPU com envio de leads.

### Resumo Geral
- Conjunto de ferramentas aplicado de forma incremental (durante implementa√ß√£o / refino / testes).
- Foco em detectar cedo: layout quebrado, jank, consumo de mem√≥ria e gargalos de rede.
- Resultado: app consistente, responsivo e com ciclo de feedback r√°pido.

## ÔøΩüîç Tratamento de Erros

### Tipos de Erro
- **ServerException**: Erros de servidor/API
- **NetworkException**: Problemas de rede
- **CacheException**: Problemas de cache/banco local
- **ValidationException**: Erros de valida√ß√£o

### Estrat√©gia de Fallback
- Tenta dados remotos primeiro
- Em caso de falha, usa cache local
- Mostra mensagens espec√≠ficas para cada erro

## üìà Melhores Pr√°ticas Implementadas

### C√≥digo
- ‚úÖ Clean Architecture
- ‚úÖ Princ√≠pios SOLID
- ‚úÖ Dependency Injection
- ‚úÖ Error Handling robusto
- ‚úÖ C√≥digo test√°vel
- ‚úÖ Documenta√ß√£o inline

### Performance
- ‚úÖ Lazy loading de depend√™ncias
- ‚úÖ Cache inteligente
- ‚úÖ Otimiza√ß√£o de builds
- ‚úÖ Memory management

### UX/UI
- ‚úÖ Loading states
- ‚úÖ Empty states
- ‚úÖ Error states
- ‚úÖ Pull-to-refresh
- ‚úÖ Feedback visual
- ‚úÖ Valida√ß√£o de formul√°rios

## üîß Configura√ß√µes de Desenvolvimento

### Android
```kotlin
minSdkVersion 21
targetSdkVersion 34
```

### iOS
```
iOS 12.0+
```

### Linting
O projeto usa `flutter_lints` para manter qualidade do c√≥digo:
```yaml
include: package:flutter_lints/flutter.yaml
```

---

**Tecnologias**: Flutter ‚Ä¢ Dart ‚Ä¢ SQLite ‚Ä¢ Clean Architecture ‚Ä¢ BLoC ‚Ä¢ SOLID ‚Ä¢ TDD